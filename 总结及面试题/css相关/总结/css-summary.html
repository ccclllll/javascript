<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <link href="../../styles/main.css" type="text/css" rel="stylesheet">
    <style>
        a:hover {
            color: #3f7ccf;
        }
    </style>
</head>
<body>
<header>
    <nav>
        <a href="css-summary.html" class="a">css总结</a>
        <a href="">css面试题</a>
        <a href="">html总结</a>
        <a href="">html面试题</a>
        <a href="">js总结</a>
        <a href="">js面试题</a>
    </nav>
</header>
<main>
    <section>
        <div>
            文档流
            HTML页面的标准文档流(默认布局)是：从上到下，从左到右，遇块(块级元素)换行。
            <p>
                元素占用的空间和元素实际的大小并不相同。块级元素占用一行，盒子的宽度是100%，但实际的宽度却可能是50%。如果此时将margin设置为auto，
                那么，浏览器会自动计算margin，是根据盒子剩余的宽度计算，剩余的宽度会平分给左右的margin。
                对于浮动元素，占用的空间和其本身的宽高一致。
            </p>
            <p>
                绝对定位元素和相对定位元素，没有实际占用文档流的空间，所以块级元素依然会挨着上一个普通流元素进行排列
            </p>
            <p>
                定位方式为relative以及没有定位时，块级元素占一行，盒子宽度为100%；元素宽度100%。绝对定位时，没有指定宽高时盒子的宽高为0，元素宽高为0。
            </p>
        </div>
        <h2>1.选择器相关</h2>
        <div class="point">
            <h3>选择器理解</h3>
            <div class="point-list">
                <div class="point-list-item">
                    <h4 class="item-title">1.后代选择器</h4>
                    <div class="item-detail">
                        <p> div p ：选择div元素里面的所有p元素 </p>
                    </div>
                    <h4 class="item-title">2.子选择器</h4>
                    <div class="item-detail">
                        <p> div > p : 选择父元素为div的所有p元素</p>
                    </div>
                    <h4 class="item-title">3.同胞选择器</h4>
                    <div class="item-detail">
                        <p>div + p : 选择所有紧跟在div之后的p元素</p>
                    </div>
                    <h4 class="item-title">4.组选择器</h4>
                    <div class="item-detail">
                        <p>div,p : 选择所有的div和p元素</p>
                    </div>

                    <h4 class="item-title">5.共同选择器</h4>
                    <div class="item-detail">
                        <p> div.name : 选择所有类名为name的div元素</p>
                    </div>

                    <p>
                        此外还有id选择器#id，伪类选择器div:hover，类选择器.name,属性选择器[attribute] [attribute=name]。<br>
                        <strong>:hover 可以选择所有指针位于其上的元素</strong>
                    </p>
                </div>
            </div>
        </div>
        <div class="point">
            <h3>选择器权重</h3>
            <div class="point-list">
                <div class="point-list-item">
                    <h4 class="item-title">1.后代选择器</h4>
                    <div class="item-detail">
                        !important > 行内样式 > id > 类选择器 ， 属性选择器 ， 伪类选择器> 元素(伪元素，标签)选择器 > 通配符<br>
                        同等级的根据选择器数量来计算权重。权重相同的样式，页内样式大于外联样式，如果同时处于页内或者外联时，先加载的会被后加载的覆盖。<br>
                        先比较元素优先级，相同时比较权重，权重相同时看位置（是页内样式还是外联样式），位置相同时看加载先后顺序。
                        <h4>题目：</h4>

                        <img src="../../imgs/code1.png">
                        <p>问a的颜色是什么？如果去掉#box a 呢？ </p>
                    </div>
                </div>
            </div>
        </div>
        <div class="point">
            <h3>2.两种盒模型</h3>
            【盒子由margin border padding content 组成】
            <div class="point-list">
                <div class="point-list-item">
                    <h4 class="item-title">ie的盒模型和标准盒模型</h4>
                    <div class="item-detail">
                        <p>
                            ie：盒子的宽高 = content + border + padding<br>
                            标准：盒子宽高 = content的宽高<br>
                            <strong>也就是说，在ie盒子模型下，指定盒子高度或者宽度之后，如果设置了border和padding，内容的宽度=盒子宽度-两边的border以及padding的宽度。<br>
                                而对于标准盒子模型，内容的宽高并不会改变，仍然等于盒子的宽高。<br>
                                box-sizing:border-box ->ie,box-sizing:content-box->标准
                            </strong>
                        </p>
                    </div>
                </div>
            </div>
        </div>

        <div class="point">
            <h3>3.定位</h3>
            定位元素位置通过 "left", "top", "right" 以及 "bottom" 属性进行规定。
            <div class="point-list">
                <p>
                <ul>
                    <li>
                        absolute:相对最近的<strong>指定定位方式的</strong>父级元素进行定位。对于绝对定位元素，可以使用top,left;right,bottom指定绝对定位元素与父元素在四个方向的偏移量。
                        当未指定绝对定位元素宽高时，可通过这四个属性来控制元素的宽高（父元素宽高-偏移量）。当指定元素宽高时，可以用这几个属性设置盒子的大小。可以用这个技巧实现自适应布局以及垂直居中对齐。
                    </li>
                    <li>
                        relative:相对自己原来的位置进行定位。
                    </li>
                    <li>
                        fixed:相对浏览器进行定位。类似绝对定位。
                    </li>
                    
                </ul>
                </p>
            </div>
            <a href="定位.html">定位例子</a>
  
        
            <p>
                <a href="http://www.w3school.com.cn/cssref/pr_class_position.asp"定位属性></a>
            </p>
            元素默认定位属性为static，表示没有定位。（忽略 top, bottom, left, right 或者 z-index 声明）。

        </div>

        <div>
            <h3>4.块级元素以及行级元素</h3>
            <ul>
                <li>
                    行级元素：span strong em a del i code (display:inline)
                </li>
                <li>
                    块级元素：div p ul li  ol form address h1-h6 (display:block) 独占一行
                </li>
                <li>
                    行级块元素：img input select button textarea (display:inline-block)
                </li>
            </ul>
            <p>
                行级元素可以嵌套行级元素，a不可嵌套a元素。块级元素可以嵌套任何元素，p不可以套div
            </p>
        </div>

        <div>
            <h3>5.margin塌陷和BFC</h3>
            <ul>
                <li>
                    嵌套塌陷:父子嵌套时，父亲的marin-top会受第一个块级元素的margin-top影响，取两者间较大的一个值，子元素的margin并不会体现出来，也就是说子元素的margin-top相当于消失了，而父元素则取两者间较大的margin-top值作为自己的外边距。
                </li>
                <li>
                    margin合并：兄弟元素。上一个元素的margin-bottom会和下一个元素的margin-top合并为一个，取两者间最大值.
                </li>
            </ul>
        </div>

        <div>
            <h3>
                6.浮动
            </h3>
            <p>
                给元素的float属性赋值后，就是脱离文档流，进行左右浮动，紧贴着父元素(默认为body文本区域)的左右边框。float之后，没给定宽度时，float的元素不会独占一行，而是尽可能小
                而此浮动元素在文档流空出的位置，由后续的(非浮动)元素填充上去：块级元素直接填充上去，若跟浮动元素的范围发生重叠，浮动元素覆盖块级元素。内联元素：有空隙就插入。
                块级元素会忽略浮动元素按照常规流进行放置。当没有足够空间放置浮动元素时，会被自动挤到下面直到可以放置元素的位置。浮动元素会将常规流元素覆盖,但是文本会自动到浮动元素没有覆盖的地方。
            </p>
            <a href="定位.html">浮动元素</a>
        </div>

        <div>
            <h3>伪元素</h3>
            <p>
                selector:after 必须加上content，默认为行级元素。
            </p>
        </div>
    </section>
</main>

</body>
</html>